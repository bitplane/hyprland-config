#!/bin/bash
# Dictation daemon - keeps catvox warm and writes to fifo

FIFO="/tmp/dictate.fifo"
PIDFILE="/tmp/dictated.pid"
TIMEOUT=600  # 10 minutes

# Check if already running
if [ -f "$PIDFILE" ]; then
    pid=$(cat "$PIDFILE")
    if ps -p "$pid" > /dev/null 2>&1; then
        # Already running, just touch pidfile to extend timeout
        touch "$PIDFILE"
        exit 0
    fi
fi

# Not running, start it up
echo $$ > "$PIDFILE"

# Create fifo if it doesn't exist
[ -p "$FIFO" ] || mkfifo "$FIFO"

# Cleanup function
cleanup() {
    # Kill our specific catvox process
    if [ -n "$catvox_pid" ]; then
        kill $catvox_pid 2>/dev/null || true
        sleep 0.1
        kill -9 $catvox_pid 2>/dev/null || true
    fi
    rm -f "$PIDFILE" "$FIFO"
    exit 0
}

trap cleanup EXIT INT TERM

# Run catvox in background, writing to fifo
catvox > "$FIFO" &
subshell_pid=$!
# Get the actual catvox PID (child of the subshell)
sleep 0.1
catvox_pid=$(pgrep -P $subshell_pid catvox 2>/dev/null || echo "")

# Monitor loop - check pidfile modification time and catvox health
while true; do
    sleep 1

    if [ ! -f "$PIDFILE" ]; then
        # Pidfile removed, exit
        break
    fi

    # Check if catvox is still running
    if [ -n "$catvox_pid" ] && ! kill -0 "$catvox_pid" 2>/dev/null; then
        # catvox died, exit
        break
    fi

    # Check if pidfile was modified in last TIMEOUT seconds
    last_modified=$(stat -c %Y "$PIDFILE" 2>/dev/null)
    now=$(date +%s)
    age=$((now - last_modified))

    if [ "$age" -gt "$TIMEOUT" ]; then
        # Timeout exceeded, exit
        break
    fi
done

cleanup

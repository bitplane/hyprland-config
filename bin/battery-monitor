#!/usr/bin/env python3
"""
Battery monitor with event-driven architecture.
Uses pyudev for AC plug/unplug events, polling only while discharging.
"""

import logging
import os
import subprocess
import time
import signal
import sys
from pathlib import Path
from threading import Thread, Event

import pyudev


# Configure logging
logging.basicConfig(
    level=logging.DEBUG if "--debug" in sys.argv else logging.WARNING,
    format="[%(levelname)s] %(message)s",
    stream=sys.stderr
)
log = logging.getLogger(__name__)

# Paths
RUNTIME_DIR = Path(os.environ.get("XDG_RUNTIME_DIR", "/tmp"))
STATEFILE = RUNTIME_DIR / "battery-monitor.state"
POWER_SUPPLY_PATH = Path("/sys/class/power_supply")


def detect_ac_device():
    """Find the AC adapter device name."""
    for device in POWER_SUPPLY_PATH.iterdir():
        type_file = device / "type"
        if type_file.exists():
            device_type = type_file.read_text().strip()
            if device_type != "Battery":
                log.debug(f"Detected AC device: {device.name}")
                return device.name
    log.warning("No AC device found, defaulting to AC0")
    return "AC0"


def detect_battery_device():
    """Find the battery device name."""
    for device in POWER_SUPPLY_PATH.iterdir():
        type_file = device / "type"
        if type_file.exists():
            device_type = type_file.read_text().strip()
            if device_type == "Battery":
                log.debug(f"Detected battery device: {device.name}")
                return device
    log.warning("No battery device found, defaulting to BAT0")
    return POWER_SUPPLY_PATH / "BAT0"


def run_keyboard_command(cmd, args):
    """Run a keyboard command and log any errors."""
    result = subprocess.run(
        [cmd] + args,
        check=False,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.PIPE
    )
    if result.stderr:
        log.debug(f"{cmd} stderr: {result.stderr.decode().strip()}")


def keyboard_notify(color):
    """Set keyboard background color (R,G,B)."""
    log.debug(f"keyboard_notify({color[0]},{color[1]},{color[2]})")
    run_keyboard_command("keyboard-notify", ["--bg-color", f"{color[0]},{color[1]},{color[2]}"])


def keyboard_reset():
    """Reset keyboard to default."""
    log.debug("keyboard_reset()")
    run_keyboard_command("keyboard-reset", [])


def get_battery_status(battery_path):
    """Get battery capacity and status."""
    try:
        capacity = int((battery_path / "capacity").read_text().strip())
        status = (battery_path / "status").read_text().strip()
        log.debug(f"Battery: {capacity}% {status}")
        return capacity, status
    except Exception as e:
        log.debug(f"Error reading battery: {e}")
        return None, None


def show_battery_color(capacity=None, battery_path=None):
    """Display battery level as keyboard color."""
    if capacity is None:
        if battery_path is None:
            return
        capacity, _ = get_battery_status(battery_path)
        if capacity is None:
            return

    if capacity > 80:
        keyboard_notify((0, 255, 0))
    elif capacity > 20:
        pos = capacity - 20
        green = int(255 * pos / 60)
        red = 255 - green
        keyboard_notify((red, green, 0))
    else:
        keyboard_notify((255, 0, 0))
        keyboard_notify((0, 0, 0))
        keyboard_notify((255, 0, 0))


class BatteryMonitor:
    def __init__(self):
        self.polling_thread = None
        self.stop_polling = Event()
        self.battery_path = detect_battery_device()
        self.ac_device = detect_ac_device()

    def start_polling(self):
        """Start background polling loop for battery updates."""
        log.debug("Starting polling loop")

        if self.polling_thread and self.polling_thread.is_alive():
            log.debug("Stopping existing polling thread")
            self.stop_polling.set()
            self.polling_thread.join(timeout=2)

        self.stop_polling.clear()
        self.polling_thread = Thread(target=self._poll_loop, daemon=True)
        self.polling_thread.start()
        log.debug("Polling loop started")

    def _poll_loop(self):
        """Polling loop that runs while discharging."""
        while not self.stop_polling.is_set():
            capacity, _ = get_battery_status(self.battery_path)
            if capacity is None:
                continue

            show_battery_color(capacity)

            if capacity > 20:
                interval = 30
            else:
                interval = max(1, capacity // 3)

            log.debug(f"Next check in {interval}s")
            self.stop_polling.wait(timeout=interval)

    def stop_polling_loop(self):
        """Stop the polling loop."""
        log.debug("Stopping polling loop")
        self.stop_polling.set()
        if self.polling_thread:
            self.polling_thread.join(timeout=2)
        log.debug("Polling loop stopped")

    def handle_unplug(self):
        """Handle AC unplugged event."""
        log.debug("AC unplugged: showing battery color and starting polling")
        capacity, _ = get_battery_status(self.battery_path)
        show_battery_color(capacity)
        self.start_polling()
        STATEFILE.touch()

    def handle_plug(self):
        """Handle AC plugged in event."""
        log.debug("AC plugged in: flash cyan and reset")
        self.stop_polling_loop()
        if STATEFILE.exists():
            keyboard_notify((0, 128, 128))
            time.sleep(1)
        keyboard_reset()
        STATEFILE.unlink(missing_ok=True)

    def run(self):
        """Main event loop."""
        log.debug("=== Battery Monitor Starting ===")
        log.debug(f"AC device: {self.ac_device}, Battery: {self.battery_path.name}")

        # Initial state
        capacity, status = get_battery_status(self.battery_path)
        if status == "Discharging":
            show_battery_color(capacity)
            self.start_polling()
            STATEFILE.touch()

        # Listen for udev events
        log.debug("Starting udev monitor for power_supply events")
        context = pyudev.Context()
        monitor = pyudev.Monitor.from_netlink(context)
        monitor.filter_by(subsystem='power_supply')

        log.debug("Listening for events...")
        for device in iter(monitor.poll, None):
            log.debug(f"udev event: action={device.action} device={device.sys_name}")
            if device.action == 'change' and device.sys_name == self.ac_device:
                ac_online = device.attributes.asstring('online')
                log.debug(f"{self.ac_device} online={ac_online}")

                if ac_online == '0':
                    self.handle_unplug()
                else:
                    self.handle_plug()


def signal_handler(signum, frame):
    """Clean exit on signals."""
    keyboard_reset()
    STATEFILE.unlink(missing_ok=True)
    sys.exit(0)


if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    monitor = BatteryMonitor()
    monitor.run()
